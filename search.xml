<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搞学习</title>
      <link href="/2019/11/19/blog-02/"/>
      <url>/2019/11/19/blog-02/</url>
      
        <content type="html"><![CDATA[<h1 id="搞学习"><a href="#搞学习" class="headerlink" title="搞学习"></a>搞学习</h1><p>沉迷学习, 无法自拔</p><p><img src="https://cha-1302853283.cos.ap-chengdu.myqcloud.com/gif/20181119125234.gif" alt="20181119125234"></p><p><img src="https://cha-1302853283.cos.ap-chengdu.myqcloud.com/gif/timg.gif" alt="timg"></p><p><img src="https://cha-1302853283.cos.ap-chengdu.myqcloud.com/gif/1191178260.gif" alt="1191178260"></p><p><img src="https://cha-1302853283.cos.ap-chengdu.myqcloud.com/gif/1191276370.gif" alt="1191276370"></p><p><img src="https://cha-1302853283.cos.ap-chengdu.myqcloud.com/gif/1189608548.gif" alt="1189608548"></p><p><img src="https://cha-1302853283.cos.ap-chengdu.myqcloud.com/gif/e7c42ec34e284f7f9435699a1cb027f1.gif" alt="e7c42ec34e284f7f9435699a1cb027f1"></p>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 表情包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC</title>
      <link href="/2019/09/27/02-11/"/>
      <url>/2019/09/27/02-11/</url>
      
        <content type="html"><![CDATA[<p>Java垃圾回收概况</p><p>　　Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代 码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对 JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，放置出现内存泄露和溢出问题。</p><p>　　关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从 1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购 的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布 的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。</p><p>　　Java GC机制主要完成3件事：确定哪些内存需要回收，确定什么时候需要执行GC，如何执行GC。经过这么长时间的发展（事实上，在Java语言出现之前，就有 GC机制的存在，如Lisp语言），Java GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究 Java GC机制。</p><p>　　学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。</p><p>　　我们将从4个方面学习Java GC机制，1，内存是如何分配的；2，如何保证内存不被错误回收（即：哪些内存需要回收）；3，在什么情况下执行GC以及执行GC的方式；4，如何监控和优化GC机制。</p><p>Java内存区域</p><p>　　了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块：</p><p>其中：</p><p>1，程序计数器（Program Counter Register）：程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。</p><p>　　每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。</p><p>　　如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写 完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区 域中唯一一个没有定义OutOfMemoryError的区域。</p><p>2，虚拟机栈（JVM Stack）：一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</p><p>　　局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占 用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定 好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。</p><p>　　虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多 数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，知道内存不足，此时，会抛出 OutOfMemoryError（内存溢出）。</p><p>　　每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p><p>3，本地方法栈（Native Method Statck）：本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。</p><p>　　本地方法栈也是线程私有的。</p><p>4，堆区（Heap）：堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。</p><p>　　一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主 流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。</p><p>　　关于堆区的内容还有很多，将在下节“Java内存分配机制”中详细介绍。</p><p>5，方法区（Method Area）：在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实 上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永 久代，HotSpot本身，也计划取消永久代。本文中，由于笔者主要使用Oracle JDK6.0，因此仍将使用永久代一词。</p><p>　　方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。</p><p>　　方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上 执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对 常量池的内存回收和对已加载类的卸载。</p><p>　　在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。</p><p>　　在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。</p><p>　　运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。</p><p>6，直接内存（Direct Memory）：直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是 JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区 （Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。 由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p><p>Java对象的访问方式</p><p>一般来说，一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。</p><p>　　以最简单的本地变量引用：Object obj = new Object()为例：</p><ul><li>Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据；</li><li>new Object()作为实例对象数据存储在堆中；</li><li>堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中；</li></ul><p>在Java虚拟机规范中，对于通过reference类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种：</p><p>1，通过句柄访问（图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）：</p><p><img src="https://images0.cnblogs.com/blog/406312/201309/21174354-8e55a4e6b6284153b8ac40cfeab3062d.png" alt=""></p><p>通过句柄访问的实现方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。</p><p>2，通过直接指针访问：（图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）</p><p><img src="https://images0.cnblogs.com/blog/406312/201309/21174413-e7b4a7cdec984c2881a56ad776d54354.png" alt=""></p><p>通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。</p><p>Java内存分配机制</p><p>这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。</p><p>　　Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。如下图（来源于《成为JavaGC专家part I》，<a href="http://www.importnew.com/1993.html）：" target="_blank" rel="noopener">http://www.importnew.com/1993.html）：</a></p><p>　　　　<img src="https://images0.cnblogs.com/blog/406312/201309/22011837-d7fa2942d1c041b8be184f503e63fa46.png" alt=""></p><p>　　年轻代（Young Generation）：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消 亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。</p><p>　　年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再 贴切不过）和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为（来源于《成为JavaGC专家part I》，<a href="http://www.importnew.com/1993.html）：" target="_blank" rel="noopener">http://www.importnew.com/1993.html）：</a></p><p>　　　　<img src="https://images0.cnblogs.com/blog/406312/201309/22014107-8698ab6bdb0f44389c0212ad2c1bae21.png" alt=""></p><ol><li>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</li><li>当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</li><li>此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；</li><li>当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。</li><li>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li></ol><p>　　从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活 着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方 式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。</p><p>　　在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread- Local Allocation Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对 象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干 段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内 存。</p><p>　　年老代（Old Generation）：对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　</p><p> 　　可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。</p><p>　　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。</p><p>　　可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p><p>Java GC机制</p><p>GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。</p><p>　　年轻代：</p><p>　　事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p><p>　　这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）</p><p>　　由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1.</p><p>　　老年代：</p><p>　　老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</p><pre><code> 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设 置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不 允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</code></pre><p>　　方法区（永久代）：</p><p>　　永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p><ol><li><p>类的所有实例都已经被回收</p></li><li><p>加载类的ClassLoader已经被回收</p></li><li><p>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</p><p> 永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制</p><p> 使用-verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息</p><p> -verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用；</p><p> -XX:+TraceClassUnLoading需要fastdebug版HotSpot支持</p></li></ol><p>垃圾收集器</p><p>在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）：</p><p>　　<img src="https://images0.cnblogs.com/blog/406312/201309/23225652-8fe6831475f9437b91ff1e9d4fa9fabb.jpg" alt=""></p><p>在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。</p><ul><li><p>Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）</p></li><li><p>ParNew收集器：新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</p></li><li><p>Parallel Scavenge 收集器：新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。使用-XX:+UseParallelGC开关控制使用 Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即 1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效）</p></li><li><p>Serial Old收集器：老年代收集器，单线程收集器，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存 的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标 记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。</p></li><li><p>Parallel Old收集器：老年代收集器，多线程，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清 理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK 1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。</p></li></ul><blockquote><p>CMS收集的方法是：先3次标记，再1次清除，3次标记中前两次是初始标记和重新标记（此时仍然需要停止（stop the world））， 初始标记（Initial Remark）是标记GC Roots能关联到的对象（即有引用的对象），停顿时间很短；并发标记（Concurrent remark）是执行GC Roots查找引用的过程，不需要用户线程停顿；重新标记（Remark）是在初始标记和并发标记期间，有标记变动的那部分仍需要标记，所以加上这一部分 标记的过程，停顿时间比并发标记小得多，但比初始标记稍长。在完成标记之后，就开始并发清除，不需要用户线程停顿。</p><p>所以在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。</p><p>CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。</p><p>另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。</p><p>还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。</p></blockquote><ul><li>G1收集器：在JDK1.7中正式发布，与现状的新生代、老年代概念有很大不同，目前使用较少，不做介绍。</li></ul><p>注意并发（Concurrent）和并行（Parallel）的区别：</p><p>并发是指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在CMS中用户线程还是需要停顿的，只是非常短，GC线程在另一个CPU上执行）；</p><p>并行收集是指多个GC线程并行工作，但此时用户线程是暂停的；</p><p>所以，Serial和Parallel收集器都是并行的，而CMS收集器是并发的.</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2019/09/09/02-01/"/>
      <url>/2019/09/09/02-01/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL优化-添加索引"><a href="#MySQL优化-添加索引" class="headerlink" title="MySQL优化-添加索引"></a>MySQL优化-添加索引</h1><blockquote><p><strong>这面试必备(背), 不想背也得背…</strong></p><p><img src="/medias/img/720677746.jpg" alt="720677746"></p></blockquote><h2 id="索引的类型："><a href="#索引的类型：" class="headerlink" title="索引的类型："></a>索引的类型：</h2><blockquote><ul><li>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值</li><li>INDEX(普通索引)：允许出现相同的索引内容</li><li>PROMARY KEY(主键索引)：不允许出现相同的值</li><li>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维</li><li>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</li></ul></blockquote><p>1.添加PRIMARY KEY（主键索引） </p><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )</code></pre><p>2.添加UNIQUE(唯一索引) </p><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `table_name` ADD UNIQUE ( `column` )</code></pre><p>3.添加INDEX(普通索引) </p><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `table_name` ADD INDEX index_name ( `column` ) </code></pre><p>4.添加FULLTEXT(全文索引) </p><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `table_name` ADD FULLTEXT ( `column`) </code></pre><p>5.添加多列索引 </p><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )</code></pre><hr><h2 id="MySQL创建单列索引"><a href="#MySQL创建单列索引" class="headerlink" title="MySQL创建单列索引"></a>MySQL创建单列索引</h2><p>单列索引是在数据表的单个字段上创建的索引。一个表中可以创建多个单列索引。唯一性索引和普通索引等都为单列索引。</p><p>实例：创建一个名为index4的数据表，在表中的subject字段上建立名为index4_st的单列索引。</p><blockquote><ul><li>创建单列索引的SQL代码如下：</li></ul><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE index4(id INT,                    subject VARCHAR(30),                    INDEX index4_st(subject(10)));</code></pre><p><strong>注意：subject字段长度为30，而index4_st设置的索引长度只有10，这样做是为了提高查询速度。对于字符型的数据，可以不用查询全部信息，而只查询它前面的若干字符信息。</strong></p></blockquote><hr><h2 id="MySQL创建多列索引"><a href="#MySQL创建多列索引" class="headerlink" title="MySQL创建多列索引"></a>MySQL创建多列索引</h2><p>创建多列索引是在表的多个字段上创建一个索引。</p><p>实例：创建一个名为index5的数据表，在表中的name和sex字段上建立名为index5_ns的多列索引。</p><blockquote><ul><li>创建多列索引的SQL代码如下：</li></ul><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE index5(id INT,                    name VARCHAR(20),                    sex CHAR(4),                    INDEX index5_ns(name,sex));</code></pre><ul><li>多列索引中，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用。</li></ul><p><strong>使用多列索引时一定要特别注意，只有使用了索引中的第一个字段时才会触发索引。如果没有使用索引中的第一个字段，那么这个多列索引就不会起作用。因此，在优化查询速度时，可以考虑优化多列索引。</strong></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro问题</title>
      <link href="/2019/07/25/02-10/"/>
      <url>/2019/07/25/02-10/</url>
      
        <content type="html"><![CDATA[<p>shiro 1.2.2和1.2.3</p><p>为shiro设置了缓存，但是当服务器运行几个小时后，页面判断</p><pre><code>&lt;shiro:hasPermission name=&quot;admin&quot;&gt;  &lt;li class=&quot;mail&quot;&gt;有权限  &lt;/li&gt;  &lt;/shiro:hasPermission&gt;</code></pre><p>一直未显示。重新登陆也无效。判断问题应该是，实际缓存失效了，但是框架仍然认为有效。</p><p>尝试无效办法</p><p>（1）</p><p>倘若把shiro对应的ehcache配置文章，该掉设置，</p><pre><code>timeToIdleSeconds=&quot;10&quot;  timeToLiveSeconds=&quot;10&quot;</code></pre><p>该问题依旧出现。但出问题频次减少</p><p>（2）在application-shiro里面添加</p><pre><code>&lt;bean id=&quot;sessionManager&quot;class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt;  &lt;!-- 超时时间 --&gt;  &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;3600&quot; /&gt;  &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot; /&gt;  &lt;!-- 定时检查失效的session --&gt;  &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot; /&gt;  &lt;/bean&gt;&lt;bean id=&quot;sessionDAO&quot;  class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt;  &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot; /&gt;  &lt;/bean&gt;</code></pre><p>依旧没用</p><p>google到 <a href="http://stackoverflow.com/questions/17657283/cache-invalidate-not-working-in-shiro" target="_blank" rel="noopener">http://stackoverflow.com/questions/17657283/cache-invalidate-not-working-in-shiro</a></p><p>(3)验证权限的时候，主动清除缓存。</p><pre><code>    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)     throws AuthenticationException {    ...    SimplePrincipalCollection principals = new SimplePrincipalCollection(username, &quot;jndiJdbcRealm&quot;);    super.doClearCache(principals);     ...}最后，在日志里面发现15:31:24.379 \[main\] DEBUG o.a.shiro.realm.AuthorizingRealm - No authorizationCache instance set. Checking for a cacheManager...  15:31:24.379 \[main\] INFO o.a.shiro.realm.AuthorizingRealm - No cache or cacheManager properties have been set. Authorization cache cannot be obtained.  15:31:24.405 \[main\] DEBUG o.a.s.s.LifecycleBeanPostProcessor - Initializing bean \[shiroEhcacheManager\]...</code></pre><p>在shiroDbRealm里面添加这一句</p><pre><code>&lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot; /&gt;</code></pre><p>问题依旧无解</p><p>终极解决</p><p>1、</p><p>log配置文件里面添加</p><pre><code>&lt;logger name=&quot;org.apache.shiro&quot; level=&quot;trace&quot; &gt;  &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;  &lt;/logger&gt;</code></pre><p>之后得到日志信息</p><pre><code>22:48:20.765 \[http-80-3\] DEBUG o.a.shiro.realm.AuthenticatingRealm - AuthenticationInfo caching is disabled for info \[null\]. </code></pre><p>加上以下内容以后，依旧无效。 </p><pre><code>&lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot; /&gt;&lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot; /&gt;</code></pre><p>根源在ShiroUser对象的tostring方法，用的是loginName,但由于业务不需要，loginName根本就没有赋值。所以字符串“NULL”是缓存的key。</p><p>故当所有人登录以后，保存的cache key是“null”，一直会互相覆盖。</p><p>改写ShiroUser的Tostring()方法，用系统唯一值登录名赋值。问题解决</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的JVM相关问题</title>
      <link href="/2019/06/29/03-08/"/>
      <url>/2019/06/29/03-08/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内存模型以及分区，需要详细到每个区放什么。"><a href="#1-内存模型以及分区，需要详细到每个区放什么。" class="headerlink" title="1. 内存模型以及分区，需要详细到每个区放什么。"></a>1. 内存模型以及分区，需要详细到每个区放什么。</h2><blockquote><p>JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面，class 类信息常量池（static 常量和 static变量）等放在方法区</p></blockquote><p><strong>方法区</strong>：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据</p><p><strong>堆</strong>：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配</p><p><strong>栈</strong>：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所以还是一个指向地址的指针</p><p><strong>本地方法栈</strong>：主要为 Native 方法服务</p><p><strong>程序计数器</strong>：记录当前线程执行的行号</p><h2 id="2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。"><a href="#2-堆里面的分区：Eden，survival-（from-to），老年代，各自的特点。" class="headerlink" title="2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。"></a>2. 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</h2><p>堆里面分为<strong>新生代</strong>和<strong>老生代</strong>（java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</p><h2 id="3-对象创建方法，对象的内存分配，对象的访问定位。"><a href="#3-对象创建方法，对象的内存分配，对象的访问定位。" class="headerlink" title="3. 对象创建方法，对象的内存分配，对象的访问定位。"></a>3. 对象创建方法，对象的内存分配，对象的访问定位。</h2><h2 id="4-GC-的两种判定方法："><a href="#4-GC-的两种判定方法：" class="headerlink" title="4. GC 的两种判定方法："></a>4. GC 的两种判定方法：</h2><p><strong>引用计数法</strong>：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况</p><p><strong>引用链法</strong>： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果不能到达 GC ROOT 就说明可以回收</p><h2 id="5-SafePoint-是什么"><a href="#5-SafePoint-是什么" class="headerlink" title="5. SafePoint 是什么"></a>5. SafePoint 是什么</h2><p>比如 GC 的时候必须要等到 Java 线程都进入到 safepoint 的时候 VMThread 才能开始执行 GC，</p><ol><li>循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入safepoint)</li><li>方法返回前</li><li>调用方法的 call 之后</li><li>抛出异常的位置</li></ol><h2 id="6-GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"><a href="#6-GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" class="headerlink" title="6. GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"></a>6. GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</h2><p>标记清除：先标记，标记完毕之后再清除，效率不高，会产生碎片<br>复制算法：分为 8：1 的 Eden 区和 survivor 区，就是上面谈到的 YGC<br>标记整理：标记完毕之后，让所有存活的对象向一端移动</p><h2 id="7-GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。"><a href="#7-GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。" class="headerlink" title="7. GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。"></a>7. GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。</h2><p><strong>并行收集器</strong>：串行收集器使用一个单独的线程进行收集，GC 时服务有停顿时间</p><p><strong>串行收集器</strong>：次要回收中使用多线程来执行</p><blockquote><p>CMS 收集器是基于“ <strong>标记— 清除</strong>”算法实现的，经过多次标记才会被清除<br>G1 从 整体来看是基于“ <strong>标记—整理</strong>”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“ <strong>复制</strong>”算法实现的</p></blockquote><h2 id="8-Minor-GC-与-Full-GC-分别在什么时候发生？"><a href="#8-Minor-GC-与-Full-GC-分别在什么时候发生？" class="headerlink" title="8. Minor GC 与 Full GC 分别在什么时候发生？"></a>8. Minor GC 与 Full GC 分别在什么时候发生？</h2><p>新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC</p><h2 id="9-几种常用的内存调试工具：jmap、jstack、jconsole、jhat"><a href="#9-几种常用的内存调试工具：jmap、jstack、jconsole、jhat" class="headerlink" title="9. 几种常用的内存调试工具：jmap、jstack、jconsole、jhat"></a>9. 几种常用的内存调试工具：jmap、jstack、jconsole、jhat</h2><p>jstack 可以看当前栈的情况，jmap 查看内存，jhat 进行 dump 堆的信息mat（eclipse 的也要了解一下）</p><h2 id="10-类加载的几个过程："><a href="#10-类加载的几个过程：" class="headerlink" title="10. 类加载的几个过程："></a>10. 类加载的几个过程：</h2><p>加载、验证、准备、解析、初始化。然后是使用和卸载了</p><p>通过全限定名来加载生成 class 对象到内存中，然后进行验证这个 class 文件，包括文件格式校验、元数据验证，字节码校验等。准备是对这个对象分配内存。解析是将符号引用转化为直接引用（指针引用），初始化就是开始执行构造器的代码</p><h2 id="11-JVM-内存分哪几个区，每个区的作用是什么"><a href="#11-JVM-内存分哪几个区，每个区的作用是什么" class="headerlink" title="11.JVM 内存分哪几个区，每个区的作用是什么?"></a>11.JVM 内存分哪几个区，每个区的作用是什么?</h2><p>java 虚拟机主要分为以下一个区:</p><p><strong>方法区：</strong></p><ol><li>有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载</li><li>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</li><li>该区域是被线程共享的。</li><li>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</li></ol><p><strong>虚拟机栈:</strong></p><ol><li>虚拟机栈也就是我们平常所称的栈内存,它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</li><li>虚拟机栈是线程私有的，它的生命周期与线程相同。</li><li>局部变量表里存储的是基本数据类型、returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</li><li>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</li><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</li></ol><p><strong>本地方法栈：</strong></p><p>本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。</p><p><strong>堆：</strong><br>java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p><p><strong>程序计数器：</strong></p><p>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。</p><h2 id="12-如和判断一个对象是否存活-或者-GC-对象的判定方法"><a href="#12-如和判断一个对象是否存活-或者-GC-对象的判定方法" class="headerlink" title="12.如和判断一个对象是否存活?(或者 GC 对象的判定方法)"></a>12.如和判断一个对象是否存活?(或者 GC 对象的判定方法)</h2><blockquote><p>判断一个对象是否存活有两种方法:</p></blockquote><ol><li>引用计数法</li></ol><p>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p><ol start="2"><li>可达性算法(引用链法)</li></ol><p>该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。</p><p>在 java 中可以作为 GC Roots 的对象有以下几种:</p><p><strong>虚拟机栈中引用的对象</strong></p><p><strong>方法区类静态属性引用的对象</strong></p><p><strong>方法区常量池引用的对象</strong></p><p><strong>本地方法栈 JNI 引用的对象</strong></p><p>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。</p><p>如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</p><h2 id="13-简述-java-垃圾回收机制"><a href="#13-简述-java-垃圾回收机制" class="headerlink" title="13.简述 java 垃圾回收机制?"></a>13.简述 java 垃圾回收机制?</h2><p>在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h2 id="14-java-中垃圾收集的方法有哪些"><a href="#14-java-中垃圾收集的方法有哪些" class="headerlink" title="14.java 中垃圾收集的方法有哪些?"></a>14.java 中垃圾收集的方法有哪些?</h2><ol><li>标记-清除:<br>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：<br>1.效率不高，标记和清除的效率都很低；<br>2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。</li><li>复制算法:<br>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)</li><li>标记-整理<br>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</li><li>分代收集<br>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</li></ol><h2 id="15-java-内存模型"><a href="#15-java-内存模型" class="headerlink" title="15.java 内存模型"></a>15.java 内存模型</h2><p>java 内存模型(JMM)是线程间通信的控制机制.JMM 定义了主内存和线程之间抽象关系。</p><p>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ol><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ol><h2 id="16-java-类加载过程"><a href="#16-java-类加载过程" class="headerlink" title="16.java 类加载过程?"></a>16.java 类加载过程?</h2><p>java 类加载需要经历一下 7 个过程：</p><p><strong>加载</strong></p><p>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p><ol><li>通过一个类的全限定名获取该类的二进制流。</li><li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</li><li>在内存中生成该类的 Class 对象，作为该类的数据访问入口。</li></ol><p><strong>验证</strong></p><p>验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:</p><ol><li>文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟<br>机范围内，常量池中的常量是否有不被支持的类型.</li><li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不<br>被继承的类等。</li><li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，<br>确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转<br>指令是否正确等。</li><li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执<br>行。</li></ol><p><strong>准备</strong></p><p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p><p>public static int value=123; //在准备阶段 value 初始值为 0 。在初始化阶段才会变<br>为 123 。</p><ul><li>1</li><li>2</li><li>1</li><li>2</li></ul><p><strong>解析</strong></p><p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p><p><strong>初始化</strong></p><p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</p><h2 id="17-简述-java-类加载机制"><a href="#17-简述-java-类加载机制" class="headerlink" title="17. 简述 java 类加载机制?"></a>17. 简述 java 类加载机制?</h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。</p><h2 id="18-类加载器双亲委派模型机制？"><a href="#18-类加载器双亲委派模型机制？" class="headerlink" title="18. 类加载器双亲委派模型机制？"></a>18. 类加载器双亲委派模型机制？</h2><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h2 id="19-什么是类加载器，类加载器有哪些"><a href="#19-什么是类加载器，类加载器有哪些" class="headerlink" title="19.什么是类加载器，类加载器有哪些?"></a>19.什么是类加载器，类加载器有哪些?</h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ol><li>启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。.</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</li></ol><h2 id="20-简述-java-内存分配与回收策率以及-Minor-GC-和Major-GC"><a href="#20-简述-java-内存分配与回收策率以及-Minor-GC-和Major-GC" class="headerlink" title="20.简述 java 内存分配与回收策率以及 Minor GC 和Major GC"></a>20.简述 java 内存分配与回收策率以及 Minor GC 和Major GC</h2><ol><li>对象优先在堆的 Eden 区分配。</li><li>大对象直接进入老年代.</li><li>长期存活的对象将直接进入老年代.</li></ol><p>当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 MinorGC 这样可以加快老年代的回收速度。</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka</title>
      <link href="/2019/06/29/03-06/"/>
      <url>/2019/06/29/03-06/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cloud-Eureka注册中心"><a href="#Spring-Cloud-Eureka注册中心" class="headerlink" title="Spring Cloud Eureka注册中心"></a>Spring Cloud Eureka注册中心</h2><blockquote><p>由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。</p></blockquote><p>Eureka是netflix的一个子模块，也是核心模块之一，Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。服务注册与发现对于微服务架构来说是非常重要的，有了服务发现和注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务，而不需要修改服务调用的配置文件了，功能类似于dubbo的注册中心，比如zookeeper。</p><p><img src="https://img-blog.csdnimg.cn/20190619213457296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTM3MTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Eureka采用了C-S的设计架构。Eureka Server作为服务注册功能的服务器，它是服务注册时中心。</p><p>而系统中的其他微服务，使用eureka的客户端连接到eureka server并维持心跳连接。这样系统的维护人员就可以通过eureka server来监控系统中各个微服务是否正常运行。SpringCloud的一些其他模块就可以通过eureka server来发现系统中的其他微服务，并执行相关的逻辑。</p><h2 id="三大角色："><a href="#三大角色：" class="headerlink" title="三大角色："></a>三大角色：</h2><p><code>Eureka Server</code>提供服务注册服务。各个服务提供者节点启动后，会在Eureka Server中进行注册，这样Eureka server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到</p><p><code>Service Provider</code>服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到。</p><p><code>Service Consumer</code>服务消费方从Eureka获取注册服务列表，从而能够消费服务。</p><p>Eureka client是一个java客户端，用于简化eureka server的交互，在应用启动后，将会向Eureka Server发送心跳。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表把这个服务节点移除。</p><h2 id="搭建简易的单机注册中心-eureka"><a href="#搭建简易的单机注册中心-eureka" class="headerlink" title="搭建简易的单机注册中心(eureka)"></a>搭建简易的单机注册中心(eureka)</h2><p>实现效果，搭建一个maven项目，作为eureka注册中心，用户注册和发现服务。可以通过一个web页面查看。<br><strong>步骤：</strong></p><blockquote><p>1、搭建一个普通的maven项目<br>2、导入pom依赖：需要web依赖和eureka的server依赖；<br>3、application.yml配置<br>4、一个springboot的启动入口类：需要增加一个eureka的服务注解<br>5、启动，页面访问web页面</p></blockquote><p>导入pom依赖：</p><pre><code>&lt;!--springboot支持--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Eureka服务端支持--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>application.yml配置</p><pre><code>server:  port: 7001eureka:  instance:    hostname: localhost  client:    registerWithEureka: false #是否要注册到eureka    fetchRegistry: false #表示是否从Eureka Server获取注册信息    serviceUrl:      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #单机配置</code></pre><p>启动入口类</p><pre><code>@SpringBootApplication@EnableEurekaServer //标识是eureka服务端public class EnrekaServerApplication_7001 {    public static void main(String[] args) {        SpringApplication.run(EnrekaServerApplication_7001.class);    }}</code></pre><p>通过启动类启动，这时候直接访问yml文件中配置的<code>localhost:7001</code><br><img src="https://img-blog.csdnimg.cn/20190619214323861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTM3MTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式篇——FastDFS</title>
      <link href="/2019/06/27/03-09/"/>
      <url>/2019/06/27/03-09/</url>
      
        <content type="html"><![CDATA[<h2 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h2><blockquote><p>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。</p></blockquote><p>FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><p>FastDFS 架构包括 Tracker(跟踪) server 和 Storage(存储) server。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。</p><p>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。</p><p>Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。<br><img src="https://img-blog.csdnimg.cn/20190627124144729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTM3MTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>服务端两个角色：</strong></p><blockquote><p>racker server：跟踪(调度)服务器：<br>storage server：文件的存储服务器</p></blockquote><p>Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。</p><p>Storage：实际保存文件 Storage 分为多个组(group)，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。</p><h2 id="上传和下载流程"><a href="#上传和下载流程" class="headerlink" title="上传和下载流程"></a>上传和下载流程</h2><blockquote><p><strong>上传</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190627124433248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTM3MTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>你要得到一个服务器端的ip和端口,使用客户端进行上传,得到服务器返回的一个文件标识,并持久化到数据库<br>客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p><p><strong>组名</strong>：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存。</p><p><strong>虚拟磁盘路径</strong>：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了<br>store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。</p><p><strong>数据两级目录</strong>：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据<br>文件。</p><p><strong>文件名</strong>：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储<br>服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p><blockquote><p><strong>下载</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190627124630829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTM3MTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><strong>参考：</strong></p></blockquote><p>官方网站：<a href="https://github.com/happyfish100/" target="_blank" rel="noopener">https://github.com/happyfish100/</a><br>配置文档：<a href="https://github.com/happyfish100/fastdfs/wiki/" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs/wiki/</a></p><p>参考资料：<a href="https://www.oschina.net/question/tag/fastdfs" target="_blank" rel="noopener">https://www.oschina.net/question/tag/fastdfs</a><br>Java客户端：<a href="https://github.com/happyfish100/fastdfs-client-java" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs-client-java</a></p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> fastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据丢失</title>
      <link href="/2019/05/19/03-05/"/>
      <url>/2019/05/19/03-05/</url>
      
        <content type="html"><![CDATA[<h2 id="数据丢失-动态修改"><a href="#数据丢失-动态修改" class="headerlink" title="数据丢失(动态修改)"></a>数据丢失(动态修改)</h2><blockquote><p>三种解决方案(隐藏域,SQL不修改,先到数据库查)<br>这里为第三种<br>@ModelAttribute : 在路径访问这个方法的时候会先执行它<br>解决n-to-n的问题<br>添加:/employee/save 修改：/employee/update?cmd=update</p></blockquote><pre><code>    @ModelAttribute(&quot;editEmployee&quot;)    public Employee beforeEdit(Long id,String cmd){        //修改的时候才查询(只要有id会就进行一次查询,这是不对的)        if(id!=null &amp;&amp; &quot;update&quot;.equals(cmd)) {            Employee dbEmp = employeeService.findOne(id);            //把要传过来的关联对象都清空，就可以解决n-to-n的问题            dbEmp.setDepartment(null);            return dbEmp;        }        return null;    }    //这里的ModelAttribute和上面的名称是对应上的    @RequestMapping(&quot;/update&quot;)    @ResponseBody    public JsonResult update(@ModelAttribute(&quot;editEmployee&quot;)Employee employee){        return saveOrUpdate(employee);    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件</title>
      <link href="/2018/09/22/03-04/"/>
      <url>/2018/09/22/03-04/</url>
      
        <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><p><a href="#_1">组件</a></p></li><li><p><a href="#_3">全局组件与局部组件</a></p></li><li><p><a href="#template_44">写template的位置</a></p></li><li><p><a href="#template_81">写template其它属性</a></p></li><li><p><a href="#_122">路由</a></p></li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="全局组件与局部组件"><a href="#全局组件与局部组件" class="headerlink" title="全局组件与局部组件"></a>全局组件与局部组件</h2><ul><li><p>取名使用小写(xxxYyyZzz -&gt; xxx-yyy-zzz)</p></li><li><p>有一个根标签</p><pre><code>&lt;div id=&quot;app&quot;&gt;    {{message}}    &lt;comp01&gt;&lt;/comp01&gt;    &lt;comp02&gt;&lt;/comp02&gt;&lt;/div&gt;&lt;hr&gt;&lt;div id=&quot;app2&quot;&gt;    &lt;comp01&gt;&lt;/comp01&gt;    &lt;comp02&gt;&lt;/comp02&gt;&lt;/div&gt;&lt;script&gt;    //定义一个全局模板    Vue.component(&quot;comp01&quot;,{        template:&quot;&lt;h1&gt;我是一个全局模板&lt;/h1&gt;&quot;    })    new Vue({        el:&quot;#app&quot;,        data:{            message:&quot;你好啊！&quot;        },        //定义一个局部标签        components:{            &quot;comp02&quot;:{                template:&quot;&lt;h2&gt;我是一个局部模板&lt;/h2&gt;&quot;            }        }    })    new Vue({        el:&quot;#app2&quot;    })&lt;/script&gt;</code></pre></li></ul><h2 id="写template的位置"><a href="#写template的位置" class="headerlink" title="写template的位置"></a>写template的位置</h2><blockquote><p>template标签</p></blockquote><pre><code>&lt;!-- template：直接在html中写 --&gt;    &lt;template id=&quot;temp02&quot;&gt;        &lt;form action=&quot;&quot; method=&quot;&quot;&gt;            用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br /&gt;            密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;br /&gt;            &lt;input type=&quot;button&quot; value=&quot;点我一下&quot;&gt;        &lt;/form&gt;    &lt;/template&gt;</code></pre><blockquote><p>script:type=text/template</p></blockquote><pre><code>&lt;!-- 直接在script中写 type=&quot;text/template&quot; --&gt;    &lt;script type=&quot;text/template&quot; id=&quot;temp03&quot;&gt;        &lt;form action=&quot;&quot; method=&quot;&quot;&gt;            年纪:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;br /&gt;            &lt;input type=&quot;button&quot; value=&quot;点我一下&quot;&gt;        &lt;/form&gt;    &lt;/script&gt;</code></pre><blockquote><p>引用</p></blockquote><pre><code> Vue.component(&quot;comp02&quot;,{            template:&quot;#temp02&quot;        })        Vue.component(&quot;comp03&quot;,{            template:&quot;#temp03&quot;        })</code></pre><h2 id="写template其它属性"><a href="#写template其它属性" class="headerlink" title="写template其它属性"></a>写template其它属性</h2><blockquote><p>准备一个模板</p></blockquote><pre><code> &lt;template id=&quot;temp01&quot;&gt;        &lt;div&gt;            &lt;h1&gt;helloword！！！{{username}}&lt;/h1&gt;            &lt;button @click=&quot;clickMe&quot;&gt;{{username}}&lt;/button&gt;        &lt;/div&gt;    &lt;/template&gt;</code></pre><blockquote><p>数据与方法（data与methods在标签中）</p></blockquote><ul><li>数据需要方法返回json值<pre><code>new Vue({        el:&quot;#app&quot;,        // data:{        //   username:&quot;admin&quot;        // },        components:{            &quot;mytag&quot;:{                template:&quot;#temp01&quot;,                //在这个模板,它需要的数据必需是一个方法返回的                data(){                    return {                        username:&quot;admin&quot;                    }                },                methods:{                    clickMe(){                        this.username = &quot;administrator&quot;;                    }                }            }        }    })</code></pre></li></ul><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><ul><li><p>路由是一个插件，需要单独引入</p><script src="js/vuejs/vue.js"></script><script src="js/vuejs/vue-router.js"></script></li><li><p>准备链接</p><div id="app">    <h1>我是一个路由!</h1>    <p>        <!-- 使用 router-link 组件来导航. -->        <!-- 通过传入 `to` 属性指定链接. -->        <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->        <router-link to="/">首页</router-link><pre><code>    &lt;router-link to=&quot;/employee&quot;&gt;员工管理&lt;/router-link&gt;    &lt;router-link to=&quot;/department&quot;&gt;部门管理&lt;/router-link&gt;&lt;/p&gt;&lt;!-- 路由出口 --&gt;&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;&lt;router-view&gt;&lt;/router-view&gt;</code></pre></div></li><li><p>创建与绑定路由</p><p>//创建一个路由对象</p><pre><code>    let router = new VueRouter({        routes:[            //路由的地址对应相应的组件            {                path: &#39;/&#39;,                component: {                    template: &#39;&lt;h1&gt;我是第一页&lt;/h1&gt;&#39;                }            },            {                path: &#39;/employee&#39;,                component: {                    template: &#39;&lt;div&gt;员工棒棒的！&lt;/div&gt;&#39;                }            },            {                path: &#39;/department&#39;,                component: {                    template: &#39;&lt;div&gt;我是部门我怕谁&lt;/div&gt;&#39;                }            }        ]    });    new Vue({        el:&quot;#app&quot;,        //绑定相应的路由       router:router    })</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue基本语法</title>
      <link href="/2018/09/21/02-03/"/>
      <url>/2018/09/21/02-03/</url>
      
        <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><p><a href="#VUE_2">一.什么是VUE</a></p></li><li><p><a href="#VUE_6">二.VUE基本语法</a></p></li><li><p><a href="#21_Vue_8">2.1 Vue的基本使用</a></p></li><li><p><a href="#22_el_38">2.2 el</a></p></li><li><p><a href="#23_data_43">2.3 data</a></p></li><li><p><a href="#24_methods_47">2.4 methods</a></p></li><li><p><a href="#VUE_54">三.VUE表达式</a></p></li><li><p><a href="#VUE_61">四.VUE的指令</a></p></li><li><p><a href="#vtextvhtml_71">v-text,v-html</a></p></li><li><p><a href="#vfor_76">v-for</a></p></li><li><p><a href="#vbind__107">v-bind: 绑定属性</a></p></li><li><p><a href="#vmodel__132">v-model: 数组双向绑定</a></p></li><li><p><a href="#vshow_149">v-show:展示与隐藏</a></p></li><li><p><a href="#vif_165">v-if:判断</a></p></li><li><p><a href="#von_182">v-on:注册事件</a></p></li><li><p><a href="#VUE_205">五.VUE组件</a></p></li><li><p><a href="#51__211">5.1 全局组件</a></p></li><li><p><a href="#52__218">5.2 局部组件</a></p></li></ul><h1 id="一-什么是VUE"><a href="#一-什么是VUE" class="headerlink" title="一.什么是VUE"></a>一.什么是VUE</h1><blockquote><p>渐进式的Javascript框架<br>MVVM(Model,View,ViewModel)模式</p></blockquote><h1 id="二-VUE基本语法"><a href="#二-VUE基本语法" class="headerlink" title="二.VUE基本语法"></a>二.VUE基本语法</h1><h2 id="2-1-Vue的基本使用"><a href="#2-1-Vue的基本使用" class="headerlink" title="2.1 Vue的基本使用"></a>2.1 Vue的基本使用</h2><ul><li><p>引用vue.js</p></li><li><p>准备要挂载的标签</p></li><li><p>创建vue对象，进行挂载</p><pre><code>&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;!--引入vue.js--&gt;    &lt;script src=&quot;js/vuejs/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    {{message}}&lt;/div&gt;&lt;script&gt;    new Vue({        el:&quot;#app&quot;, //挂载        data:{            message:&quot;hello,Vue!&quot;        },        methods:{        }});</code></pre></li></ul><pre><code>&lt;/script&gt;&lt;/body&gt;</code></pre><pre><code>2.2 el------*   指定相应的挂载对象*   可以使用id,class,标签(建议使用id挂载)*   挂载后代表这个标签被vue接管2.3 data--------*   vue对象准备的数据*   这个数据发生变化后,用到它的view部分值也改变2.4 methods-----------*   vue中对象的方法*   在html中 {{方法()}}*   在js vue对象.方法()*   方法中的this就是指这个vue对象三.VUE表达式========*   做四则运算(+,-,\*,/)*   三目运算符*   可以调用字符串,对象,数组的方法(在{{}}直接写js代码的感觉)&gt; 注意:对象中也可以有方法,并且可以调用(如非必要不建议这样写)四.VUE的指令========&gt; 指令就是 v-属性*   v-text,v-html :展示相应的数据*   v-for ：循环*   v-bind: 绑定属性*   v-model: 数组双向绑定(input,select,textarea)*   v-show：显示也隐藏*   v-if: 判断*   v-on: 注册事件v-text,v-html-------------*   v-html会读到html标签(会显示标签的效果)*   v-text会把标签当做字符串显示*   注意:标签中如果加了它们，里面的值就会被替换v-for-----*   可以循环数组,对象，数字与字符串</code></pre><pre><code>&lt;div id=&quot;app&quot;&gt;    直接拿到数组中的值    &lt;div v-for=&quot;v in hobbys&quot;&gt;{{v}}&lt;/div&gt;     直接拿到数组中的值与索引    &lt;div v-for=&quot;(v,i) in hobbys&quot;&gt;{{v}}&lt;/div&gt;     直接拿到对象的属性值    &lt;div v-for=&quot;v in user&quot;&gt;{{v}}&lt;/div&gt;    直接拿到对象的属性值，属性名,索引    &lt;div v-for=&quot;(v,k,i) in user&quot;&gt;{{v}}&lt;/div&gt;&lt;/div&gt;new Vue({    el:&quot;#app&quot;,    data:{        hobbys:[&quot;空调&quot;,&quot;吃饭&quot;,&quot;睡觉&quot;,&quot;打豆豆&quot;],        user:{            id:1,            username:&quot;隔壁王哥&quot;,            age:45,            sex:true        },        num:10,        name:&quot;itsource&quot;    }})</code></pre><pre><code>v-bind: 绑定属性------------&gt; 可以让属性在vue对象中取值</code></pre><pre><code>&lt;div id=&quot;app&quot;&gt;    标签形式    &lt;img v-bind:src=&quot;src&quot; /&gt;    简写形式    &lt;img :src=&quot;src&quot; /&gt;    直接绑定所有属性     &lt;img v-bind=&quot;attr&quot; /&gt;&lt;/div&gt;new Vue({    el:&quot;#app&quot;,    data:{        src:&quot;1.jpg&quot;,        attr:{            src:&quot;1.jpg&quot;,            width:40,            height:40        }    }})</code></pre><pre><code>v-model: 数组双向绑定---------------*   只能作用于(input,select,textarea)</code></pre><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;textVal&quot;&gt;    {{textVal}}&lt;/div&gt;new Vue({    el:&quot;#app&quot;,    data:{        textVal:&quot;xxxx&quot;    }})</code></pre><pre><code>v-show:展示与隐藏------------&gt; 只是隐藏(display:none)</code></pre><div id="app">      <div v-show="true">显示我吧</div>      <div v-show="show">显示我吧</div>    </div><pre><code>new Vue({    el:&quot;#app&quot;,    data:{        show:true    }})</code></pre><pre><code>v-if:判断-------&gt; v-if,v-else-if,v-else(不显示dom元素就删除)</code></pre><div id="app">     <div v-if="score>=90">你很棒</div>     <div v-else-if="score>=60 && score<90">你努力</div>     <div v-else>你不行</div>    </div><pre><code>new Vue({    el:&quot;#app&quot;,    data:{        score:80    }})</code></pre><pre><code>v-on:注册事件---------</code></pre><div id="app">     标准写法     <button v-on:click="alert(0)"></button>     简写形式     <button @click="alert(1)"></button>     调用方法(加不加括号都可以实现)     <button @click="say"></button>     <button @click="say()"></button>    </div><pre><code>new Vue({    el:&quot;#app&quot;,    data:{        score:80    },    methods:{        say(){}    }})</code></pre><pre><code>五.VUE组件=======*   先创建组件后挂载*   template(模块)中，有且只有一个根*   取名用小写(如果是驼峰 myTag -&gt; my-tag)5.1 全局组件--------&gt; 所有被挂载的位置都可以使用</code></pre><p>Vue.component(“mytag”,{<br>            template:”<div>我有100句代码!</div>“<br>        });</p><pre><code>5.2 局部组件--------&gt; 只能在当前被挂载的元素中使用</code></pre><p>new Vue({<br>            el:”#app”,<br>            //创建局部的组件<br>            components:{<br>                //组件的名称<br>                “mytag”:{<br>                 template:”<div>我是一个局部的组件！</div>“<br>                }<br>            }<br>        })</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人理解面向对象</title>
      <link href="/2018/08/24/03-07/"/>
      <url>/2018/08/24/03-07/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>和很多广义的面向对象说法对比而言，我这里首先采用的是一种比较狭义的理解<br>一方面是因为鄙人确实技术及理论水平有限，一方面也是为了让很多初学者更容易接受，从而由浅入深逐渐了解乃至于衍生出自己的理解</p><h2 id="狭义理解面向对象"><a href="#狭义理解面向对象" class="headerlink" title="狭义理解面向对象"></a>狭义理解面向对象</h2><p>面向对象可以说是一种思维方式，我这里以面向结构作引入并以生产汽车为实例进行介绍：</p><p><strong>面向过程</strong>的方式就为了保证汽车的质量，所以由大到小一系类的操作流程都需要自己严格地考量，实现了每一个环节的以及环节之间的复杂关系才能保证生产汽车的品质</p><p><strong>面向对象</strong>同样是为了保证汽车的质量，所以我可以选择专业生产轮胎的张三家生产的轮胎，可以选择专注发动机研发的李四家的发动机，可以选择各种行更专业的厂家，而且我不必要知道其他人的东西是怎样生产的，只需要知道他们的产品是如何使用的就行了</p><p>说到这里可能就会有人要问了，你既然说了生产汽车了，那么你选择了那么多不同厂家的东西，不会造成不同产品之间的兼容性问题吗？</p><p>针对这样的问题我要说到的就是Java面向对象的三大特性之一的<strong>封装</strong>(后面会出相关的博客详细的介绍<strong>Java的三大特性[封装、继承、多态]</strong>)</p><p>封装就是把过程和数据包围起来，对数据的访问只能通过已定义不会对其内部造成影响的方式，把这种个特性映射到生产汽车的例子就是：各个厂家对自己的配件做了封装处理，并同时预留了不会损害其内部功能也不会对外部造成影响的一些”方法”来使用它们生产的配件</p><p>这种思想在java程序编写中的体现就是：</p><p>Java内部提供了<strong>海量且功能十分强大</strong>的类库(从本质上来说和我们自己写的类没有什么差别，而从功能上来说他的每一个类都是经历了历代前辈们的考量与优化比我们自己写的更加得可靠)，并提供了API文档介绍他的各种类的功能及用法，通过对这些类库的使用就可以更快的实现开发与维护过程</p><h2 id="接下来讲讲广义的面向对象的说法"><a href="#接下来讲讲广义的面向对象的说法" class="headerlink" title="接下来讲讲广义的面向对象的说法"></a>接下来讲讲广义的面向对象的说法</h2><p>有一种说法叫做”万事万物介对象”<br>　<br>就是说不管是什么你都可以把他看做是一个整体，而这个整体就是一个对象，而这个整体的功能、行为和属性就是对象的功能和属性</p><p>比如一只鸟就是一个对象，一条街也是一个对象，甚至一段歌声也可以是一个对象，一阵风，一场雨都可以是一个对象，他们都具有自己的功能和属性；</p><p>程序就是源自于生活的写照，是衍只于生活而又不脱离生活的一种表达方式，所以面向对象就是面对生活，对象与对象之间的关系在计算机系统得以体现从而构建计算机系统</p><p>以上均个人观点不具有权威性，如果与什么理解上的偏失与误区或与您的观点有冲突之处还请不予吝啬给出您宝贵的建议</p>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro</title>
      <link href="/2018/08/12/02-02/"/>
      <url>/2018/08/12/02-02/</url>
      
        <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><p><a href="#1shiro_1">1.shiro的认识</a></p></li><li><p><a href="#11_Spring_security_4">1.1 和Spring security区别</a></p></li><li><p><a href="#12_shiro_11">1.2 shiro的四大基石</a></p></li><li><p><a href="#2shiroapi_16">2.shiro的核心api</a></p></li><li><p><a href="#21_securityManager_18">2.1 操作之前，先得到securityManager对象</a></p></li><li><p><a href="#22__31">2.2 使用的方法</a></p></li><li><p><a href="#3_52">3.密码加密功能</a></p></li><li><p><a href="#4Realm_65">4.自定义Realm</a></p></li><li><p><a href="#5Spring_124">5.集成Spring</a></p></li><li><p><a href="#51__127">5.1 导包</a></p></li><li><p><a href="#52_webxml_144">5.2 web.xml</a></p></li><li><p><a href="#53_applicationshiroxml_163">5.3 application-shiro.xml</a></p></li></ul><h1 id="1-shiro的认识"><a href="#1-shiro的认识" class="headerlink" title="1.shiro的认识"></a>1.shiro的认识</h1><blockquote><p>权限框架(提供的易用的API,功能强大)</p></blockquote><h2 id="1-1-和Spring-security区别"><a href="#1-1-和Spring-security区别" class="headerlink" title="1.1 和Spring security区别"></a>1.1 和Spring security区别</h2><table><thead><tr><th><strong>框架</strong></th><th><strong>shiro</strong></th><th><strong>Spring security</strong></th></tr></thead><tbody><tr><td>易用性</td><td>√</td><td>X</td></tr><tr><td>粒度</td><td>粗</td><td>细(强大)</td></tr></tbody></table><h2 id="1-2-shiro的四大基石"><a href="#1-2-shiro的四大基石" class="headerlink" title="1.2 shiro的四大基石"></a>1.2 shiro的四大基石</h2><blockquote><p>身份验证、授权、密码学和会话管理<br>securityManager:核心对象 realm:获取数据接口</p></blockquote><h1 id="2-shiro的核心api"><a href="#2-shiro的核心api" class="headerlink" title="2.shiro的核心api"></a>2.shiro的核心api</h1><h2 id="2-1-操作之前，先得到securityManager对象"><a href="#2-1-操作之前，先得到securityManager对象" class="headerlink" title="2.1 操作之前，先得到securityManager对象"></a>2.1 操作之前，先得到securityManager对象</h2><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//一.创建我们自己的Realm</span>MyRealm myRealm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRealm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//二.搞一个核心对象:</span>DefaultSecurityManager securityManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>securityManager<span class="token punctuation">.</span><span class="token function">setRealm</span><span class="token punctuation">(</span>myRealm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//三.把securityManager放到上下文中</span>SecurityUtils<span class="token punctuation">.</span><span class="token function">setSecurityManager</span><span class="token punctuation">(</span>securityManager<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="2-2-使用的方法"><a href="#2-2-使用的方法" class="headerlink" title="2.2 使用的方法"></a>2.2 使用的方法</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.拿到当前用户</span>Subject currentUser <span class="token operator">=</span> SecurityUtils<span class="token punctuation">.</span><span class="token function">getSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2.判断是否登录</span>currentUser<span class="token punctuation">.</span><span class="token function">isAuthenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3.登录(需要令牌的)</span><span class="token comment" spellcheck="true">/**    UnknownAccountException:用户名不存在    IncorrectCredentialsException:密码错误    AuthenticationException:其它错误*/</span> UsernamePasswordToken token <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordToken</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> currentUser<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4.判断是否是这个角色/权限</span>currentUser<span class="token punctuation">.</span><span class="token function">hasRole</span><span class="token punctuation">(</span><span class="token string">"角色名"</span><span class="token punctuation">)</span>currentUser<span class="token punctuation">.</span><span class="token function">isPermitted</span><span class="token punctuation">(</span><span class="token string">"权限名"</span><span class="token punctuation">)</span></code></pre><h1 id="3-密码加密功能"><a href="#3-密码加密功能" class="headerlink" title="3.密码加密功能"></a>3.密码加密功能</h1><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * String algorithmName, Object source, Object salt, int hashIterations) * 第一个参数algorithmName:加密算法名称 * 第二个参数source:加密原密码 * 第三个参数salt:盐值 * 第四个参数hashIterations:加密次数 */</span>SimpleHash hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleHash</span><span class="token punctuation">(</span><span class="token string">"MD5"</span><span class="token punctuation">,</span><span class="token string">"123456"</span><span class="token punctuation">,</span><span class="token string">"itsource"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">toHex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="4-自定义Realm"><a href="#4-自定义Realm" class="headerlink" title="4.自定义Realm"></a>4.自定义Realm</h1><blockquote><p>继承AuthorizingRealm<br>实现两个方法：doGetAuthorizationInfo(授权) /doGetAuthenticationInfo(登录认证)</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//身份认证</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> AuthenticationInfo <span class="token function">doGetAuthenticationInfo</span><span class="token punctuation">(</span>AuthenticationToken authenticationToken<span class="token punctuation">)</span> <span class="token keyword">throws</span> AuthenticationException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1.拿用户名与密码</span>    UsernamePasswordToken token <span class="token operator">=</span> <span class="token punctuation">(</span>UsernamePasswordToken<span class="token punctuation">)</span>authenticationToken<span class="token punctuation">;</span>    String username <span class="token operator">=</span> token<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2.根据用户名拿对应的密码</span>    String password <span class="token operator">=</span> <span class="token function">getByName</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>password<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回空代表用户名有问题</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//返回认证信息</span>    <span class="token comment" spellcheck="true">//准备盐值</span>    ByteSource salt <span class="token operator">=</span> ByteSource<span class="token punctuation">.</span>Util<span class="token punctuation">.</span><span class="token function">bytes</span><span class="token punctuation">(</span><span class="token string">"itsource"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//密码是shiro自己进行判断</span>    SimpleAuthenticationInfo authenticationInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAuthenticationInfo</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span>password<span class="token punctuation">,</span>salt<span class="token punctuation">,</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> authenticationInfo<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//授权</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> AuthorizationInfo <span class="token function">doGetAuthorizationInfo</span><span class="token punctuation">(</span>PrincipalCollection principalCollection<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//拿到用户名  Principal:主体(用户对象/用户名)</span>    String username <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>principalCollection<span class="token punctuation">.</span><span class="token function">getPrimaryPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//拿到角色</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> roles <span class="token operator">=</span> <span class="token function">findRolesBy</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//拿到权限</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> permis <span class="token operator">=</span> <span class="token function">findPermsBy</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//把角色权限交给用户</span>    SimpleAuthorizationInfo authorizationInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAuthorizationInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    authorizationInfo<span class="token punctuation">.</span><span class="token function">setRoles</span><span class="token punctuation">(</span>roles<span class="token punctuation">)</span><span class="token punctuation">;</span>    authorizationInfo<span class="token punctuation">.</span><span class="token function">setStringPermissions</span><span class="token punctuation">(</span>permis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> authorizationInfo<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​    </p><blockquote><p>注意:如果我们的密码加密，应该怎么判断(匹配器)</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//一.创建我们自己的Realm</span>MyRealm myRealm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRealm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个凭证匹配器(无法设置盐值)</span>HashedCredentialsMatcher matcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashedCredentialsMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  使用MD5的方式比较密码</span>matcher<span class="token punctuation">.</span><span class="token function">setHashAlgorithmName</span><span class="token punctuation">(</span><span class="token string">"md5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置编码的迭代次数</span>matcher<span class="token punctuation">.</span><span class="token function">setHashIterations</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置凭证匹配器(加密方式匹配)</span>myRealm<span class="token punctuation">.</span><span class="token function">setCredentialsMatcher</span><span class="token punctuation">(</span>matcher<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="5-集成Spring"><a href="#5-集成Spring" class="headerlink" title="5.集成Spring"></a>5.集成Spring</h1><blockquote><p>去找：shiro-root-1.4.0-RC2\samples\spring</p></blockquote><h2 id="5-1-导包"><a href="#5-1-导包" class="headerlink" title="5.1 导包"></a>5.1 导包</h2><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- shiro的支持包 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.shiro<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>shiro-all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- shiro与Spring的集成包 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.shiro<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>shiro-spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="5-2-web-xml"><a href="#5-2-web-xml" class="headerlink" title="5.2 web.xml"></a>5.2 web.xml</h2><blockquote><p>这个过滤器是一个代码(只关注它的名称)</p></blockquote><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>shiroFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.DelegatingFilterProxy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>targetFilterLifecycle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>shiroFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span></code></pre><h2 id="5-3-application-shiro-xml"><a href="#5-3-application-shiro-xml" class="headerlink" title="5.3 application-shiro.xml"></a>5.3 application-shiro.xml</h2><blockquote><p>在咱们的application引入</p></blockquote><p><code>&lt;import resource=&quot;classpath:applicationContext-shiro.xml&quot; /&gt;</code></p><blockquote><p>是从案例中拷备过来，进行了相应的修改</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><p>​        <!-- 创建securityManager这个核心对象 --><br>​        <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"><br>​            <!-- 设置一个realm进去 --><br>​            <property name="realm" ref="jpaRealm"/><br>​        </bean><br>​    </p><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- 被引用的realm(一定会写一个自定义realm) --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jpaRealm<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.itsource.aisell.shiro.JpaRealm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 为这个realm设置相应的匹配器 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>credentialsMatcher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.shiro.authc.credential.HashedCredentialsMatcher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 设置加密方式 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hashAlgorithmName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>md5<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 设置加密次数 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hashIterations<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--  可以让咱们的权限判断支持【注解】方法 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lifecycleBeanPostProcessor<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.shiro.spring.LifecycleBeanPostProcessor<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator<span class="token punctuation">"</span></span>          <span class="token attr-name">depends-on</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lifecycleBeanPostProcessor<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>securityManager<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>securityManager<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>​        <!--  真正实现权限的过滤器 它的id名称和web.xml中的过滤器名称一样 --><br>​        <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"><br>​            <property name="securityManager" ref="securityManager"/><br>​            <!-- 登录路径:如果没有登录，就会跳到这里来 --><br>​            <property name="loginUrl" value="/s/login.jsp"/><br>​            <!-- 登录成功后的跳转路径 --><br>​            <property name="successUrl" value="/s/main.jsp"/><br>​            <!-- 没有权限跳转的路径 --><br>​            <property name="unauthorizedUrl" value="/s/unauthorized.jsp"/><br>​            <!--​                anon:这个路径不需要登录也可以访问​                authc:需要登录才可以访问​                perms[depts:index]:做权限拦截​                    咱们以后哪些访问有权限拦截,需要从数据库中读取​            --><br>​            <!--​            <property name="filterChainDefinitions">​                <value>​                    /s/login.jsp = anon​                    /login = anon​                    /s/permission.jsp = perms[user:index]​                    /depts/index = perms[depts:index]​                    /** = authc​                </value>​            </property>​            --><br>​            <property name="filterChainDefinitionMap" ref="filterChainDefinitionMap" /><br>​        </bean><br>​        <!-- 实例工厂设置 --><br>​        &lt;bean id=”filterChainDefinitionMap”<br>​              factory-bean=”filterChainDefinitionMapFactory”<br>​              factory-method=”createFilterChainDefinitionMap” /&gt;<br>​        <!-- 创建可以拿到权限map的bean --><br>​        <bean id="filterChainDefinitionMapFactory" class="cn.itsource.aisell.shiro.FilterChainDefinitionMapFactory" /><br>​    </beans></p><p>​    </p><p>5.4 获取Map过滤</p><blockquote><p>注意，返回的Map必需是有序的（LinkedHashMap）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterChainDefinitionMapFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 后面这个值会从数据库中来拿     * /s/login.jsp = anon     * /login = anon     * /s/permission.jsp = perms[user:index]     * /depts/index = perms[depts:index]     * /** = authc     */</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> <span class="token function">createFilterChainDefinitionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//注:LinkedHashMap是有序的</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> filterChainDefinitionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChainDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"/s/login.jsp"</span><span class="token punctuation">,</span> <span class="token string">"anon"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChainDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">,</span> <span class="token string">"anon"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChainDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"/s/permission.jsp"</span><span class="token punctuation">,</span> <span class="token string">"perms[user:index]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChainDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"/depts/index"</span><span class="token punctuation">,</span> <span class="token string">"perms[depts:index]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChainDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">,</span> <span class="token string">"authc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> filterChainDefinitionMap<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
